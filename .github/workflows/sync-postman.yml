name: Sync Postman Collection

on:
  push:
    branches: [ main, master ]
    paths:
      - '**/*-postman.json'
  workflow_dispatch:

jobs:
  sync-postman:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
      
    - name: Find Postman Collection
      id: find-collection
      run: |
        COLLECTION=$(find . -name "*-postman.json" | head -1)
        if [ -z "$COLLECTION" ]; then
          echo "‚ùå Nenhuma collection *-postman.json encontrada"
          exit 1
        fi
        echo "collection=$COLLECTION" >> $GITHUB_OUTPUT
        echo "‚úÖ Collection encontrada: $COLLECTION"
        
    - name: Debug Secrets
      run: |
        if [ -z "${{ secrets.POSTMAN_API_KEY }}" ]; then
          echo "‚ùå POSTMAN_API_KEY n√£o configurado nos secrets"
          exit 1
        else
          echo "‚úÖ POSTMAN_API_KEY encontrado"
        fi
        
    - name: Sync Postman Collection
      env:
        POSTMAN_API_KEY: ${{ secrets.POSTMAN_API_KEY }}
        COLLECTION_FILE: ${{ steps.find-collection.outputs.collection }}
      run: |
        # Extrai collection ID do arquivo
        COLLECTION_ID=$(jq -r '.info.uid // .info._postman_id' "$COLLECTION_FILE")
        COLLECTION_NAME=$(jq -r '.info.name' "$COLLECTION_FILE")
        
        echo "Collection ID encontrado: $COLLECTION_ID"
        echo "Collection Name: $COLLECTION_NAME"
        
        # Prepara JSON no formato esperado pela API
        jq '{"collection": .}' "$COLLECTION_FILE" > wrapped_collection.json
        
        # Verifica se collection existe no Postman
        if curl -s -H "X-API-Key: $POSTMAN_API_KEY" \
           "https://api.getpostman.com/collections/$COLLECTION_ID" \
           | jq -e '.collection' > /dev/null 2>&1; then
          
          echo "üìù Collection existe - atualizando..."
          curl -X PUT \
            "https://api.getpostman.com/collections/$COLLECTION_ID" \
            -H "X-API-Key: $POSTMAN_API_KEY" \
            -H "Content-Type: application/json" \
            -d @wrapped_collection.json \
            --fail-with-body
          echo "‚úÖ Collection atualizada com sucesso!"
          
        else
          
          echo "üÜï Collection n√£o existe - criando nova..."
          
          # Debug: mostra o JSON que ser√° enviado
          echo "üìã JSON a ser enviado:"
          cat wrapped_collection.json | head -20
          
          RESPONSE=$(curl -X POST \
            "https://api.getpostman.com/collections" \
            -H "X-API-Key: $POSTMAN_API_KEY" \
            -H "Content-Type: application/json" \
            -d @wrapped_collection.json \
            -w "\nHTTP Status: %{http_code}\n" \
            --fail-with-body || echo "Erro na cria√ß√£o da collection")
          
          echo "üìã Resposta da API:"
          echo "$RESPONSE"
          
          NEW_ID=$(echo "$RESPONSE" | jq -r '.collection.id // .collection.uid')
          echo "‚úÖ Collection criada com ID: $NEW_ID"
          
          # Atualiza o arquivo local com o novo ID
          jq ".info._postman_id = \"$NEW_ID\"" "$COLLECTION_FILE" > temp.json
          mv temp.json "$COLLECTION_FILE"
          echo "üìù Arquivo local atualizado com novo ID"
          
        fi
        
        # Limpa arquivo tempor√°rio
        rm -f wrapped_collection.json